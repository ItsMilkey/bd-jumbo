-- ************************************************************************************
-- SISTEMA DE GESTIÓN DE INVENTARIO - CARNICERÍA (FUSIÓN FINAL V4)
-- AUTORES: Hans Gómez, Francisco Mardonez
-- FECHA: 13/11/2025
-- DESCRIPCIÓN: Versión definitiva optimizada para Oracle APEX.
--              Integra estructura robusta + lógica de negocio + suite de pruebas.
-- ************************************************************************************

/************************************************************************************
* 1. LIMPIEZA DE ENTORNO (Clean Slate)
************************************************************************************/
BEGIN
    -- Borrado en orden inverso a dependencias para evitar conflictos
    FOR c IN (SELECT table_name FROM user_tables WHERE table_name IN 
             ('AUDITORIAS_INVENTARIO', 'ALERTAS_INVENTARIO', 'MOVIMIENTOS_INVENTARIO', 
              'DETALLE_ORDEN', 'ORDENES_COMPRA', 'PRODUCTOS_CARNE', 'EMPLEADOS', 
              'CATEGORIAS_CARNE', 'PROVEEDORES', 'SUPERMERCADOS')) 
    LOOP
        EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS';
    END LOOP;
    
    -- Borrado de objetos lógicos
    BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE pkg_inventario_carnes'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP TYPE productos_alerta_varray FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
    
    EXECUTE IMMEDIATE 'PURGE RECYCLEBIN';
    DBMS_OUTPUT.PUT_LINE('--- Entorno limpiado correctamente ---');
END;
/

/************************************************************************************
* 2. CREACIÓN DE OBJETOS DE BASE DE DATOS
************************************************************************************/

CREATE OR REPLACE TYPE productos_alerta_varray AS VARRAY(100) OF NUMBER;
/

CREATE TABLE supermercados (
    supermercado_id     NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150) NOT NULL,
    direccion           VARCHAR2(200),
    telefono            VARCHAR2(20),
    correo_contacto     VARCHAR2(100),
    estado              CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
    fecha_registro      DATE DEFAULT SYSDATE
);

CREATE TABLE proveedores (
    proveedor_id        NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150) NOT NULL,
    rut                 VARCHAR2(20) UNIQUE NOT NULL,
    telefono            VARCHAR2(20),
    correo              VARCHAR2(100) UNIQUE NOT NULL,
    estado              CHAR(1) DEFAULT 'A',
    fecha_registro      DATE DEFAULT SYSDATE,
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id)
);

CREATE TABLE categorias_carne (
    categoria_id        NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(100) NOT NULL,
    descripcion         VARCHAR2(200),
    estado              CHAR(1) DEFAULT 'A',
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id)
);

CREATE TABLE empleados (
    empleado_id         NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150) NOT NULL,
    rut                 VARCHAR2(20) UNIQUE NOT NULL,
    cargo               VARCHAR2(100),
    telefono            VARCHAR2(20),
    correo              VARCHAR2(100),
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id),
    estado              CHAR(1) DEFAULT 'A'
);

CREATE TABLE productos_carne (
    producto_id         NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150) NOT NULL,
    categoria_id        NUMBER(10) REFERENCES categorias_carne(categoria_id),
    precio_por_kg       NUMBER(10,2) CHECK (precio_por_kg > 0),
    stock_actual_kg     NUMBER(10,3) DEFAULT 0 CHECK (stock_actual_kg >= 0),
    stock_minimo_kg     NUMBER(10,3) DEFAULT 10 CHECK (stock_minimo_kg >= 0),
    proveedor_id        NUMBER(10) REFERENCES proveedores(proveedor_id),
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id),
    estado              CHAR(1) DEFAULT 'A'
);

CREATE TABLE ordenes_compra (
    orden_id            NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    proveedor_id        NUMBER(10) REFERENCES proveedores(proveedor_id),
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id),
    fecha_orden         DATE DEFAULT SYSDATE,
    total               NUMBER(12,2),
    estado              VARCHAR2(20) DEFAULT 'PENDIENTE' CHECK (estado IN ('PENDIENTE', 'RECIBIDA', 'CANCELADA'))
);

CREATE TABLE detalle_orden (
    detalle_id          NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    orden_id            NUMBER(10) REFERENCES ordenes_compra(orden_id),
    producto_id         NUMBER(10) REFERENCES productos_carne(producto_id),
    cantidad_kg         NUMBER(10,3) CHECK (cantidad_kg > 0),
    precio_por_kg       NUMBER(10,2) CHECK (precio_por_kg >= 0)
);

CREATE TABLE movimientos_inventario (
    movimiento_id       NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    producto_id         NUMBER(10) REFERENCES productos_carne(producto_id),
    tipo_movimiento     VARCHAR2(20) CHECK (tipo_movimiento IN ('INGRESO','EGRESO', 'MERMA')),
    cantidad_kg         NUMBER(10,3) CHECK (cantidad_kg > 0),
    fecha_movimiento    DATE DEFAULT SYSDATE,
    observacion         VARCHAR2(200),
    empleado_id         NUMBER(10) REFERENCES empleados(empleado_id),
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id)
);

CREATE TABLE alertas_inventario (
    alerta_id           NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    producto_id         NUMBER(10) REFERENCES productos_carne(producto_id),
    fecha_alerta        DATE DEFAULT SYSDATE,
    tipo_alerta         VARCHAR2(50) CHECK (tipo_alerta IN ('BAJO STOCK','SIN STOCK', 'POR_VENCER')),
    descripcion         VARCHAR2(200) NOT NULL,
    atendida            CHAR(1) DEFAULT 'N' CHECK (atendida IN ('S','N'))
);

CREATE TABLE auditorias_inventario (
    auditoria_id        NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    producto_id         NUMBER(10) REFERENCES productos_carne(producto_id),
    fecha_hora          TIMESTAMP DEFAULT SYSTIMESTAMP,
    empleado_id         NUMBER(10) REFERENCES empleados(empleado_id),
    supermercado_id     NUMBER(10) REFERENCES supermercados(supermercado_id),
    stock_sistema_kg    NUMBER(10,3),
    stock_real_kg       NUMBER(10,3),
    diferencia_kg       NUMBER(10,3),
    motivo              VARCHAR2(200)
);

-- Índices
CREATE INDEX idx_prod_cat_super ON productos_carne(categoria_id, supermercado_id);
CREATE INDEX idx_oc_prov ON ordenes_compra(proveedor_id);
CREATE INDEX idx_mov_prod_fecha ON movimientos_inventario(producto_id, fecha_movimiento);
/

/************************************************************************************
* 3. TRIGGER DE ALERTAS
************************************************************************************/
CREATE OR REPLACE TRIGGER trg_alerta_stock
AFTER UPDATE OF stock_actual_kg ON productos_carne
FOR EACH ROW
DECLARE
    v_tipo_alerta VARCHAR2(50);
    l_count NUMBER;
BEGIN
    IF :NEW.stock_actual_kg <= NVL(:NEW.stock_minimo_kg, 0) AND :OLD.stock_actual_kg > NVL(:NEW.stock_minimo_kg, 0) THEN
        v_tipo_alerta := CASE WHEN :NEW.stock_actual_kg = 0 THEN 'SIN STOCK' ELSE 'BAJO STOCK' END;

        SELECT COUNT(*) INTO l_count FROM alertas_inventario
        WHERE producto_id = :NEW.producto_id AND tipo_alerta = v_tipo_alerta AND atendida = 'N';

        IF l_count = 0 THEN
           INSERT INTO alertas_inventario (producto_id, tipo_alerta, descripcion)
           VALUES (:NEW.producto_id, v_tipo_alerta, 'El corte "' || :NEW.nombre || '" (stock: ' || :NEW.stock_actual_kg || ' kg) requiere reposición.');
        END IF;
    END IF;
END;
/

/************************************************************************************
* 4. PAQUETE PL/SQL (PKG_INVENTARIO_CARNES)
************************************************************************************/
CREATE OR REPLACE PACKAGE pkg_inventario_carnes AS
    -- Constantes
    MAX_DELTA_KG         CONSTANT NUMBER := 1000;
    DEFAULT_STOCK_MINIMO CONSTANT NUMBER := 10;

    -- Excepciones y Mapeo (Pragmas aquí para que funcionen en APEX/Oracle)
    ex_stock_insuficiente       EXCEPTION; PRAGMA EXCEPTION_INIT(ex_stock_insuficiente, -20010);
    ex_cantidad_invalida        EXCEPTION; PRAGMA EXCEPTION_INIT(ex_cantidad_invalida, -20011);
    ex_tipo_movimiento_invalido EXCEPTION; PRAGMA EXCEPTION_INIT(ex_tipo_movimiento_invalido, -20012);
    ex_producto_no_encontrado   EXCEPTION; PRAGMA EXCEPTION_INIT(ex_producto_no_encontrado, -20013);
    ex_orden_no_encontrada      EXCEPTION; PRAGMA EXCEPTION_INIT(ex_orden_no_encontrada, -20022);
    ex_orden_ya_recibida        EXCEPTION; PRAGMA EXCEPTION_INIT(ex_orden_ya_recibida, -20024);
    ex_orden_cancelada          EXCEPTION; PRAGMA EXCEPTION_INIT(ex_orden_cancelada, -20025);

    -- Métodos Públicos
    PROCEDURE registrar_movimiento(p_producto_id IN NUMBER, p_tipo_movimiento IN VARCHAR2, p_cantidad_kg IN NUMBER, p_empleado_id IN NUMBER, p_supermercado_id IN NUMBER);
    FUNCTION verificar_stock_kg(p_producto_id IN NUMBER) RETURN NUMBER;
    PROCEDURE crear_orden_compra_header(p_proveedor_id IN NUMBER, p_supermercado_id IN NUMBER, p_nueva_orden_id OUT NUMBER);
    PROCEDURE agregar_detalle_orden(p_orden_id IN NUMBER, p_producto_id IN NUMBER, p_cantidad_kg IN NUMBER, p_precio_por_kg IN NUMBER);
    PROCEDURE recibir_orden_compra(p_orden_id IN NUMBER, p_empleado_id IN NUMBER);
    FUNCTION obtener_productos_bajo_minimo(p_categoria_id IN NUMBER) RETURN productos_alerta_varray;
    PROCEDURE registrar_auditoria_conteo (p_producto_id IN NUMBER, p_cantidad_real_kg IN NUMBER, p_empleado_id IN NUMBER, p_supermercado_id IN NUMBER, p_motivo IN VARCHAR2 DEFAULT 'CONTEO FISICO');
END pkg_inventario_carnes;
/

CREATE OR REPLACE PACKAGE BODY pkg_inventario_carnes AS

    PROCEDURE p_actualizar_stock(p_producto_id IN NUMBER, p_delta_kg IN NUMBER) IS
    BEGIN
        UPDATE productos_carne SET stock_actual_kg = stock_actual_kg + p_delta_kg WHERE producto_id = p_producto_id;
    END p_actualizar_stock;

    PROCEDURE registrar_movimiento(p_producto_id IN NUMBER, p_tipo_movimiento IN VARCHAR2, p_cantidad_kg IN NUMBER, p_empleado_id IN NUMBER, p_supermercado_id IN NUMBER) IS
        v_stock_actual_kg NUMBER;
        v_sign NUMBER;
        v_movimiento_norm VARCHAR2(20) := UPPER(TRIM(p_tipo_movimiento));
    BEGIN
        IF p_cantidad_kg <= 0 OR p_cantidad_kg > MAX_DELTA_KG THEN RAISE ex_cantidad_invalida; END IF;
        SELECT stock_actual_kg INTO v_stock_actual_kg FROM productos_carne WHERE producto_id = p_producto_id FOR UPDATE;

        IF v_movimiento_norm IN ('EGRESO', 'MERMA') THEN
            IF v_stock_actual_kg < p_cantidad_kg THEN RAISE ex_stock_insuficiente; END IF;
            v_sign := -1;
        ELSIF v_movimiento_norm = 'INGRESO' THEN
            v_sign := 1;
        ELSE
            RAISE ex_tipo_movimiento_invalido;
        END IF;

        INSERT INTO movimientos_inventario (producto_id, tipo_movimiento, cantidad_kg, empleado_id, supermercado_id)
        VALUES (p_producto_id, v_movimiento_norm, p_cantidad_kg, p_empleado_id, p_supermercado_id);
        p_actualizar_stock(p_producto_id, v_sign * p_cantidad_kg);
    EXCEPTION WHEN NO_DATA_FOUND THEN RAISE_APPLICATION_ERROR(-20013, 'Producto no encontrado: ' || p_producto_id);
    END registrar_movimiento;

    FUNCTION verificar_stock_kg(p_producto_id IN NUMBER) RETURN NUMBER IS
        v_stock_kg NUMBER;
    BEGIN
        SELECT stock_actual_kg INTO v_stock_kg FROM productos_carne WHERE producto_id = p_producto_id;
        RETURN v_stock_kg;
    EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL;
    END verificar_stock_kg;

    PROCEDURE crear_orden_compra_header(p_proveedor_id IN NUMBER, p_supermercado_id IN NUMBER, p_nueva_orden_id OUT NUMBER) IS
    BEGIN
        INSERT INTO ordenes_compra (proveedor_id, supermercado_id, total) VALUES (p_proveedor_id, p_supermercado_id, 0) RETURNING orden_id INTO p_nueva_orden_id;
    EXCEPTION WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20020, 'Error crear orden: ' || SQLERRM);
    END crear_orden_compra_header;

    PROCEDURE agregar_detalle_orden(p_orden_id IN NUMBER, p_producto_id IN NUMBER, p_cantidad_kg IN NUMBER, p_precio_por_kg IN NUMBER) IS
    BEGIN
        INSERT INTO detalle_orden (orden_id, producto_id, cantidad_kg, precio_por_kg) VALUES (p_orden_id, p_producto_id, p_cantidad_kg, p_precio_por_kg);
        UPDATE ordenes_compra SET total = NVL(total, 0) + (p_cantidad_kg * p_precio_por_kg) WHERE orden_id = p_orden_id;
    EXCEPTION WHEN NO_DATA_FOUND THEN RAISE_APPLICATION_ERROR(-20021, 'Datos no existen.'); WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20020, 'Error detalle: ' || SQLERRM);
    END agregar_detalle_orden;

    PROCEDURE recibir_orden_compra(p_orden_id IN NUMBER, p_empleado_id IN NUMBER) IS
        CURSOR c_detalle IS SELECT producto_id, cantidad_kg FROM detalle_orden WHERE orden_id = p_orden_id;
        v_supermercado_id NUMBER;
        v_orden_estado    VARCHAR2(20);
    BEGIN
        SELECT estado, supermercado_id INTO v_orden_estado, v_supermercado_id FROM ordenes_compra WHERE orden_id = p_orden_id FOR UPDATE;
        IF v_orden_estado = 'RECIBIDA' THEN RAISE ex_orden_ya_recibida;
        ELSIF v_orden_estado = 'CANCELADA' THEN RAISE ex_orden_cancelada; END IF;

        FOR v_row IN c_detalle LOOP
            registrar_movimiento(v_row.producto_id, 'INGRESO', v_row.cantidad_kg, p_empleado_id, v_supermercado_id);
        END LOOP;
        UPDATE ordenes_compra SET estado = 'RECIBIDA' WHERE orden_id = p_orden_id;
    EXCEPTION WHEN NO_DATA_FOUND THEN RAISE ex_orden_no_encontrada;
    END recibir_orden_compra;

    FUNCTION obtener_productos_bajo_minimo (p_categoria_id IN NUMBER) RETURN productos_alerta_varray IS
        v_lista_ids productos_alerta_varray := productos_alerta_varray();
    BEGIN
        SELECT producto_id BULK COLLECT INTO v_lista_ids FROM productos_carne WHERE categoria_id = p_categoria_id AND stock_actual_kg < stock_minimo_kg;
        RETURN v_lista_ids;
    EXCEPTION WHEN OTHERS THEN RETURN productos_alerta_varray();
    END obtener_productos_bajo_minimo;

    PROCEDURE registrar_auditoria_conteo (p_producto_id IN NUMBER, p_cantidad_real_kg IN NUMBER, p_empleado_id IN NUMBER, p_supermercado_id IN NUMBER, p_motivo IN VARCHAR2 DEFAULT 'CONTEO FISICO') IS
        v_stock_sistema_kg NUMBER;
        v_diferencia_kg    NUMBER;
    BEGIN
        IF p_cantidad_real_kg < 0 THEN RAISE_APPLICATION_ERROR(-20002, 'Cantidad negativa.'); END IF;
        BEGIN SELECT stock_actual_kg INTO v_stock_sistema_kg FROM productos_carne WHERE producto_id = p_producto_id FOR UPDATE;
        EXCEPTION WHEN NO_DATA_FOUND THEN RAISE ex_producto_no_encontrado; END;
        v_diferencia_kg := p_cantidad_real_kg - v_stock_sistema_kg;
        IF v_diferencia_kg != 0 THEN
            INSERT INTO auditorias_inventario (producto_id, fecha_hora, empleado_id, supermercado_id, stock_sistema_kg, stock_real_kg, diferencia_kg, motivo)
            VALUES (p_producto_id, SYSTIMESTAMP, p_empleado_id, p_supermercado_id, v_stock_sistema_kg, p_cantidad_real_kg, v_diferencia_kg, p_motivo);
            UPDATE productos_carne SET stock_actual_kg = p_cantidad_real_kg WHERE producto_id = p_producto_id;
        END IF;
    EXCEPTION WHEN OTHERS THEN RAISE;
    END registrar_auditoria_conteo;
END pkg_inventario_carnes;
/

/************************************************************************************
* 5. CARGA DE DATOS (Con IDs explícitos para que funcionen las pruebas)
************************************************************************************/
BEGIN
    DBMS_OUTPUT.PUT_LINE('--- Insertando datos Maestros... ---');

    -- 1. Supermercados
    INSERT INTO supermercados (supermercado_id, nombre, direccion) VALUES (1, 'Supermercado Central', 'Av. Principal 123');
    INSERT INTO supermercados (supermercado_id, nombre, direccion) VALUES (2, 'Sucursal Norte', 'Calle Falsa 456');
    INSERT INTO supermercados (supermercado_id, nombre, direccion, estado) VALUES (3, 'Bodega Logística', 'Ruta 5 Sur Km 100', 'I');

    -- 2. Empleados
    INSERT ALL
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (1, 'Juan Pérez', '1-1', 'Jefe de Carnicería', 1)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (2, 'Ana Rojas', '2-2', 'Carnicera', 1)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (3, 'Carlos Muñoz', '3-3', 'Bodeguero', 3)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (4, 'María López', '4-4', 'Carnicera', 2)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (5, 'Pedro Soto', '5-5', 'Jefe de Sección', 2)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (6, 'Luisa Vera', '6-6', 'Ayudante Carnicero', 1)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id) VALUES (7, 'Jorge Díaz', '7-7', 'Reponedor', 2)
        INTO empleados (empleado_id, nombre, rut, cargo, supermercado_id, estado) VALUES (8, 'Elena Gómez', '8-8', 'Ex-Carnicera', 1, 'I')
    SELECT 1 FROM DUAL;

    -- 3. Proveedores
    INSERT ALL
        INTO proveedores (proveedor_id, nombre, rut, correo, supermercado_id) VALUES (1, 'Frigorífico del Sur', '77.123.456-K', 'ventas@frigosur.cl', 1)
        INTO proveedores (proveedor_id, nombre, rut, correo, supermercado_id) VALUES (2, 'Carnes Premium Ltda.', '78.987.654-J', 'contacto@carnespremium.cl', 1)
        INTO proveedores (proveedor_id, nombre, rut, correo, supermercado_id) VALUES (3, 'Distribuidora Andina', '76.543.210-9', 'pedidos@andina.com', 2)
        INTO proveedores (proveedor_id, nombre, rut, correo, supermercado_id) VALUES (4, 'Aves del Campo', '75.111.222-3', 'aves@campo.cl', 1)
        INTO proveedores (proveedor_id, nombre, rut, correo, supermercado_id, estado) VALUES (5, 'Proveedor Antiguo', '70.000.000-0', 'old@prov.com', 1, 'I')
    SELECT 1 FROM DUAL;

    -- 4. Categorías
    INSERT ALL
        INTO categorias_carne (categoria_id, nombre, supermercado_id) VALUES (1, 'Vacuno', 1)
        INTO categorias_carne (categoria_id, nombre, supermercado_id) VALUES (2, 'Pollo', 1)
        INTO categorias_carne (categoria_id, nombre, supermercado_id) VALUES (3, 'Cerdo', 1)
        INTO categorias_carne (categoria_id, nombre, supermercado_id) VALUES (4, 'Pavo', 2)
        INTO categorias_carne (categoria_id, nombre, supermercado_id) VALUES (5, 'Cordero', 1)
    SELECT 1 FROM DUAL;

    -- 5. Productos (IDs forzados para coincidir con los tests de abajo)
    -- ID 1: Lomo Vetado (Usado en Test 2.2, 2.4)
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (1, 'Lomo Vetado', 1, 19990, 5.0, 1, 1);
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (2, 'Asiento Picana', 1, 15500, 8.0, 2, 1);
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (3, 'Entraña', 1, 22500, 3.0, 1, 1);
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (4, 'Posta Negra', 1, 11990, 10.0, 2, 2);
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (5, 'Tapabarriga', 1, 13490, 6.0, 1, 1);
    
    -- ID 6: Pechuga Entera (Usado en Test 2.1, 4.2, 6.1)
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (6, 'Pechuga Entera', 2, 6990, 10.0, 4, 1);
    -- ID 7: Trutro Corto (Usado en Test 4.2)
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_actual_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (7, 'Trutro Corto', 2, 4500, 15.0, 5.0, 4, 1);
    
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (8, 'Alitas de Pollo', 2, 3990, 12.0, 4, 2);
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (9, 'Pollo Entero Faenado', 2, 3500, 8.0, 4, 1);
    -- ID 10: Pulpa Pierna (Usado en Test 2.2, 2.3)
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (10, 'Pulpa Pierna', 3, 7200, 7.5, 2, 1);

    -- Otros productos para relleno
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (11, 'Costillar Ahumado', 3, 9900, 4.0, 2, 1);
    INSERT INTO productos_carne (producto_id, nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES (12, 'Pechuga Pavo', 4, 8990, 5.0, 4, 2);
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Datos cargados exitosamente.');
END;
/


/************************************************************************************
* 6. PRUEBAS UNITARIAS (TEST SUITE)
************************************************************************************/

-- PRUEBA 2: MOVIMIENTOS DE INVENTARIO
DECLARE
    v_stock_pechuga NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.1 Prueba: Verificar stock inicial CERO ---');
    v_stock_pechuga := pkg_inventario_carnes.verificar_stock_kg(6); -- Pechuga Entera
    DBMS_OUTPUT.PUT_LINE('Stock inicial de Pechuga (ID 6): ' || v_stock_pechuga || ' kg (Esperado: 0)');

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.2 Prueba: Ingreso inicial de varios productos ---');
    pkg_inventario_carnes.registrar_movimiento(1, 'INGRESO', 20.5, 1, 1);
    pkg_inventario_carnes.registrar_movimiento(6, 'INGRESO', 35.0, 1, 1);
    pkg_inventario_carnes.registrar_movimiento(10, 'INGRESO', 15.8, 1, 1);
    DBMS_OUTPUT.PUT_LINE('Ingresos registrados para Lomo(1), Pechuga(6) y Pulpa(10).');

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.3 Prueba: Registrar MERMA ---');
    pkg_inventario_carnes.registrar_movimiento(10, 'MERMA', 0.3, 2, 1);
    DBMS_OUTPUT.PUT_LINE('MERMA de 0.3 kg de Pulpa Pierna (ID 10) registrada.');

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.4 Prueba: Egreso que activa alerta de bajo stock ---');
    pkg_inventario_carnes.registrar_movimiento(1, 'EGRESO', 16.0, 2, 1);
    DBMS_OUTPUT.PUT_LINE('EGRESO de 16.0 kg de Lomo Vetado (ID 1) registrado. Stock actual: 4.5 kg.');
    COMMIT;
END;
/

-- PRUEBA 3: ERRORES CONTROLADOS
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 3.1 Prueba Fallida: Registrar movimiento con cantidad negativa ---');
    BEGIN
        pkg_inventario_carnes.registrar_movimiento(1, 'INGRESO', -5.0, 1, 1);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió registrar cantidad negativa.');
    EXCEPTION
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
    END;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 3.2 Prueba Fallida: Agregar detalle a orden inexistente ---');
    BEGIN
        pkg_inventario_carnes.agregar_detalle_orden(999, 1, 1.0, 19000);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió agregar detalle a orden 999.');
    EXCEPTION
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
    END;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 3.3 Prueba Fallida: Registrar MERMA con stock insuficiente ---');
    BEGIN
        -- Quedan 4.5 kg de Lomo (ID 1), intentamos mermar 5kg
        pkg_inventario_carnes.registrar_movimiento(1, 'MERMA', 5.0, 2, 1);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió MERMA con stock insuficiente.');
    EXCEPTION
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
    END;
END;
/

-- PRUEBA 4: CICLO DE COMPRA
DECLARE
    v_nueva_orden_id NUMBER;
    v_stock_antes NUMBER;
    v_stock_despues NUMBER;
    v_orden_estado VARCHAR2(20);
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 4.1 Prueba Compra: Crear cabecera de Orden ---');
    pkg_inventario_carnes.crear_orden_compra_header(1, 1, v_nueva_orden_id);
    DBMS_OUTPUT.PUT_LINE('Orden de compra creada con ID: ' || v_nueva_orden_id);

    DBMS_OUTPUT.PUT_LINE('--- 4.2 Prueba Compra: Agregar detalles a la orden ---');
    pkg_inventario_carnes.agregar_detalle_orden(v_nueva_orden_id, 6, 30.0, 6500); -- Pechuga
    pkg_inventario_carnes.agregar_detalle_orden(v_nueva_orden_id, 7, 25.0, 4000); -- Trutro
    DBMS_OUTPUT.PUT_LINE('Productos agregados a la orden.');

    SELECT estado INTO v_orden_estado FROM ordenes_compra WHERE orden_id = v_nueva_orden_id;
    v_stock_antes := pkg_inventario_carnes.verificar_stock_kg(6);
    DBMS_OUTPUT.PUT_LINE('Estado actual de la orden: ' || v_orden_estado);
    DBMS_OUTPUT.PUT_LINE('Stock de Pechuga (ID 6) ANTES de recibir: ' || v_stock_antes || ' kg');

    DBMS_OUTPUT.PUT_LINE('--- 4.3 Prueba Compra: Recibir el pedido ---');
    pkg_inventario_carnes.recibir_orden_compra(v_nueva_orden_id, 1);
    v_stock_despues := pkg_inventario_carnes.verificar_stock_kg(6);
    SELECT estado INTO v_orden_estado FROM ordenes_compra WHERE orden_id = v_nueva_orden_id;
    DBMS_OUTPUT.PUT_LINE('¡Orden RECIBIDA! El stock ha sido actualizado.');
    DBMS_OUTPUT.PUT_LINE('Stock de Pechuga (ID 6) DESPUÉS de recibir: ' || v_stock_despues || ' kg');
    DBMS_OUTPUT.PUT_LINE('Estado final de la orden: ' || v_orden_estado);
    COMMIT;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 4.4 Prueba Fallida: Intentar recibir la misma orden de nuevo ---');
    BEGIN
        pkg_inventario_carnes.recibir_orden_compra(v_nueva_orden_id, 1);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió recibir una orden ya procesada.');
    EXCEPTION
        WHEN pkg_inventario_carnes.ex_orden_ya_recibida THEN DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('FALLO INESPERADO: ' || SQLERRM);
    END;
END;
/

-- PRUEBA 5: COLECCIONES
DECLARE
    v_lista_ids_vacuno productos_alerta_varray;
    v_lista_ids_pollo  productos_alerta_varray;
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 5.1 Prueba Colecciones: Obtener productos BAJO MÍNIMO de Vacuno ---');
    -- Lomo (ID 1) debería estar bajo mínimo (4.5kg < 5kg) tras la prueba 2.4
    v_lista_ids_vacuno := pkg_inventario_carnes.obtener_productos_bajo_minimo(p_categoria_id => 1);

    IF v_lista_ids_vacuno.COUNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Productos Vacuno bajo mínimo encontrados (' || v_lista_ids_vacuno.COUNT || '):');
        FOR i IN 1..v_lista_ids_vacuno.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('- ID Producto: ' || v_lista_ids_vacuno(i));
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('No se encontraron productos Vacuno bajo mínimo.');
    END IF;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 5.2 Prueba Colecciones: Obtener productos BAJO MÍNIMO de Pollo ---');
    -- Trutro Corto (ID 7) fue insertado con stock (15kg) > mínimo (5kg). No debería aparecer.
    v_lista_ids_pollo := pkg_inventario_carnes.obtener_productos_bajo_minimo(p_categoria_id => 2);

    IF v_lista_ids_pollo.COUNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Productos Pollo bajo mínimo encontrados: ' || v_lista_ids_pollo.COUNT);
    ELSE
        DBMS_OUTPUT.PUT_LINE('No se encontraron productos Pollo bajo mínimo, como se esperaba.');
    END IF;
END;
/

-- PRUEBA 6: AUDITORÍA
DECLARE
    v_producto_id_test    CONSTANT NUMBER := 6; -- Pechuga Entera
    v_stock_antes         NUMBER;
    v_stock_despues       NUMBER;
    v_conteo_real_kg      CONSTANT NUMBER := 60.0;
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 6.1 Prueba Auditoría: Ajuste por Conteo Físico ---');

    -- Verificar stock del sistema ANTES del ajuste
    v_stock_antes := pkg_inventario_carnes.verificar_stock_kg(v_producto_id_test);
    DBMS_OUTPUT.PUT_LINE('Stock en Sistema (Antes): ' || v_stock_antes || ' kg para Producto ID ' || v_producto_id_test);

    -- Simular y ejecutar el conteo
    DBMS_OUTPUT.PUT_LINE('Realizando conteo... Cantidad física contada: ' || v_conteo_real_kg || ' kg.');
    pkg_inventario_carnes.registrar_auditoria_conteo(
        p_producto_id       => v_producto_id_test,
        p_cantidad_real_kg  => v_conteo_real_kg,
        p_empleado_id       => 5,
        p_supermercado_id   => 1,
        p_motivo            => 'AJUSTE POR CONTEO SEMANAL'
    );

    -- Verificar el stock del sistema DESPUÉS del ajuste
    v_stock_despues := pkg_inventario_carnes.verificar_stock_kg(v_producto_id_test);
    DBMS_OUTPUT.PUT_LINE('Stock en Sistema (Después): ' || v_stock_despues || ' kg.');

    IF v_stock_despues = v_conteo_real_kg THEN
        DBMS_OUTPUT.PUT_LINE('ÉXITO: El stock del sistema se ha corregido al conteo real.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('FALLO: El stock del sistema NO se corrigió correctamente.');
    END IF;
    COMMIT;
END;
/