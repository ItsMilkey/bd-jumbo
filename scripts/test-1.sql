-- ************************************************************************************
--
-- AUTORES: Hans Gómez, Francisco Mardonez (con mejoras de GitHub Copilot)
-- FECHA: 13/11/2025
-- PROYECTO: Sistema de Gestión de Inventario - Carnicería Supermercado Jumbo
-- DESCRIPCIÓN: Script integral para la creación, prueba y despliegue del esquema
--              de base de datos y la lógica de negocio en PL/SQL. Incluye:
--              1. Limpieza del entorno.
--              2. Creación de tipos y tablas con índices optimizados.
--              3. Creación de triggers para alertas.
--              4. Paquete PL/SQL centralizado (pkg_inventario_carnes).
--              5. Bloques de prueba exhaustivos para validar la funcionalidad.
--
-- ************************************************************************************

/************************************************************************************
*
* SCRIPT DE LIMPIEZA
* Elimina todos los objetos para asegurar un entorno limpio antes de la creación.
*
************************************************************************************/
BEGIN
   FOR c IN (SELECT 'DROP ' || object_type || ' ' || object_name ||
                    CASE WHEN object_type = 'TABLE' THEN ' CASCADE CONSTRAINTS' ELSE '' END AS cmd
             FROM user_objects
             WHERE object_name IN (
                'PKG_INVENTARIO_CARNES', 'TRG_ALERTA_STOCK', 'PRODUCTOS_ALERTA_VARRAY',
                'DETALLE_ORDEN', 'ORDENES_COMPRA', 'AUDITORIAS_INVENTARIO',
                'ALERTAS_INVENTARIO', 'MOVIMIENTOS_INVENTARIO', 'PRODUCTOS_CARNE',
                'EMPLEADOS', 'CATEGORIAS_CARNE', 'PROVEEDORES', 'SUPERMERCADOS'
             ))
   LOOP
      EXECUTE IMMEDIATE c.cmd;
   END LOOP;
   EXECUTE IMMEDIATE 'PURGE RECYCLEBIN';
   DBMS_OUTPUT.PUT_LINE('Entorno de base de datos limpiado.');
EXCEPTION
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error durante la limpieza: ' || SQLERRM || '. Es posible que algunos objetos no existieran, lo cual es normal.');
END;
/


/************************************************************************************
*
* 1. CREACIÓN DE TIPOS (VARRAY)
*
************************************************************************************/

CREATE OR REPLACE TYPE productos_alerta_varray AS VARRAY(100) OF NUMBER; -- Array para guardar IDs de productos
/

/************************************************************************************
*
* 2. CREACIÓN DE TABLAS (Dominio: Carnicería)
*
************************************************************************************/

CREATE TABLE supermercados (
    supermercado_id     NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150)   NOT NULL,
    direccion           VARCHAR2(200),
    telefono            VARCHAR2(20),
    correo_contacto     VARCHAR2(100),
    estado              CHAR(1)         DEFAULT 'A' CHECK (estado IN ('A','I')),
    fecha_registro      DATE            DEFAULT SYSDATE
);
COMMENT ON TABLE supermercados IS 'Almacena la información de las sucursales del supermercado.';

CREATE TABLE proveedores (
    proveedor_id        NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150)   NOT NULL,
    rut                 VARCHAR2(20)    UNIQUE NOT NULL,
    telefono            VARCHAR2(20),
    correo              VARCHAR2(100)   UNIQUE NOT NULL,
    estado              CHAR(1)         DEFAULT 'A' CHECK (estado IN ('A','I')),
    fecha_registro      DATE            DEFAULT SYSDATE,
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id)
);
COMMENT ON TABLE proveedores IS 'Proveedores de productos cárnicos (frigoríficos).';

CREATE TABLE categorias_carne (
    categoria_id        NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(100)   NOT NULL,
    descripcion         VARCHAR2(200),
    estado              CHAR(1)         DEFAULT 'A' CHECK (estado IN ('A','I')),
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id)
);
COMMENT ON TABLE categorias_carne IS 'Clasificación de los tipos de carne (Vacuno, Pollo, Cerdo, etc.).';

CREATE TABLE empleados (
    empleado_id         NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150)   NOT NULL,
    rut                 VARCHAR2(20)    UNIQUE NOT NULL,
    cargo               VARCHAR2(100),
    telefono            VARCHAR2(20),
    correo              VARCHAR2(100),
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id),
    estado              CHAR(1)         DEFAULT 'A' CHECK (estado IN ('A','I'))
);
COMMENT ON TABLE empleados IS 'Empleados que interactúan con el sistema de inventario.';

CREATE TABLE productos_carne (
    producto_id         NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre              VARCHAR2(150)   NOT NULL,
    categoria_id        NUMBER(10)      REFERENCES categorias_carne(categoria_id),
    precio_por_kg       NUMBER(10,2)    CHECK (precio_por_kg > 0),
    stock_actual_kg     NUMBER(10,3)    DEFAULT 0 CHECK (stock_actual_kg >= 0),
    stock_minimo_kg     NUMBER(10,3)    DEFAULT 10 CHECK (stock_minimo_kg >= 0),
    proveedor_id        NUMBER(10)      REFERENCES proveedores(proveedor_id),
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id),
    estado              CHAR(1)         DEFAULT 'A' CHECK (estado IN ('A','I'))
);
COMMENT ON TABLE productos_carne IS 'Tabla maestra de productos cárnicos. El stock se gestiona aquí.';

CREATE TABLE ordenes_compra (
    orden_id            NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    proveedor_id        NUMBER(10)      REFERENCES proveedores(proveedor_id),
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id),
    fecha_orden         DATE            DEFAULT SYSDATE,
    total               NUMBER(12,2),
    estado              VARCHAR2(20)    DEFAULT 'PENDIENTE' CHECK (estado IN ('PENDIENTE', 'RECIBIDA', 'CANCELADA'))
);
COMMENT ON TABLE ordenes_compra IS 'Cabecera de las órdenes de compra a proveedores.';

CREATE TABLE detalle_orden (
    detalle_id          NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    orden_id            NUMBER(10)      REFERENCES ordenes_compra(orden_id),
    producto_id         NUMBER(10)      REFERENCES productos_carne(producto_id),
    cantidad_kg         NUMBER(10,3)    CHECK (cantidad_kg > 0),
    precio_por_kg       NUMBER(10,2)    CHECK (precio_por_kg >= 0)
);
COMMENT ON TABLE detalle_orden IS 'Líneas de detalle para cada orden de compra.';

CREATE TABLE movimientos_inventario (
    movimiento_id       NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    producto_id         NUMBER(10)      REFERENCES productos_carne(producto_id),
    tipo_movimiento     VARCHAR2(20)    CHECK (tipo_movimiento IN ('INGRESO','EGRESO', 'MERMA')),
    cantidad_kg         NUMBER(10,3)    CHECK (cantidad_kg > 0),
    fecha_movimiento    DATE            DEFAULT SYSDATE,
    observacion         VARCHAR2(200),
    empleado_id         NUMBER(10)      REFERENCES empleados(empleado_id),
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id)
);
COMMENT ON TABLE movimientos_inventario IS 'Log de todos los movimientos de stock (ingresos, egresos, mermas).';

CREATE TABLE alertas_inventario (
    alerta_id           NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    producto_id         NUMBER(10)      REFERENCES productos_carne(producto_id),
    fecha_alerta        DATE            DEFAULT SYSDATE,
    tipo_alerta         VARCHAR2(50)    CHECK (tipo_alerta IN ('BAJO STOCK','SIN STOCK', 'POR_VENCER')),
    descripcion         VARCHAR2(200)   NOT NULL,
    atendida            CHAR(1)         DEFAULT 'N' CHECK (atendida IN ('S','N'))
);
COMMENT ON TABLE alertas_inventario IS 'Registra alertas automáticas generadas por el sistema (ej. bajo stock).';

CREATE TABLE auditorias_inventario (
    auditoria_id        NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    producto_id         NUMBER(10)      REFERENCES productos_carne(producto_id),
    fecha_hora          TIMESTAMP       DEFAULT SYSTIMESTAMP,
    empleado_id         NUMBER(10)      REFERENCES empleados(empleado_id),
    supermercado_id     NUMBER(10)      REFERENCES supermercados(supermercado_id),
    stock_sistema_kg    NUMBER(10,3),
    stock_real_kg       NUMBER(10,3),
    diferencia_kg       NUMBER(10,3),
    motivo              VARCHAR2(200)
);
COMMENT ON TABLE auditorias_inventario IS 'Registra los resultados de conteos físicos y los ajustes de stock realizados.';
/

-- Creación de Índices para optimizar rendimiento según especificación
CREATE INDEX idx_prod_cat_super ON productos_carne(categoria_id, supermercado_id);
CREATE INDEX idx_oc_prov ON ordenes_compra(proveedor_id);
CREATE INDEX idx_mov_prod_fecha ON movimientos_inventario(producto_id, fecha_movimiento);
/

/************************************************************************************
*
* 3. CREACIÓN DE TRIGGERS
*
************************************************************************************/

CREATE OR REPLACE TRIGGER trg_alerta_stock
AFTER UPDATE OF stock_actual_kg ON productos_carne
FOR EACH ROW
DECLARE
    v_tipo_alerta VARCHAR2(50);
    l_count NUMBER;
BEGIN
    -- Se dispara solo si el stock cruza el umbral mínimo hacia abajo.
    IF :NEW.stock_actual_kg <= NVL(:NEW.stock_minimo_kg, 0) AND :OLD.stock_actual_kg > NVL(:NEW.stock_minimo_kg, 0) THEN

        v_tipo_alerta := CASE WHEN :NEW.stock_actual_kg = 0 THEN 'SIN STOCK' ELSE 'BAJO STOCK' END;

        -- Idempotencia: No crear una nueva alerta si ya existe una abierta (atendida = 'N')
        SELECT COUNT(*)
        INTO l_count
        FROM alertas_inventario
        WHERE producto_id = :NEW.producto_id
          AND tipo_alerta = v_tipo_alerta
          AND atendida = 'N';

        IF l_count = 0 THEN
           INSERT INTO alertas_inventario (producto_id, tipo_alerta, descripcion)
           VALUES (:NEW.producto_id, v_tipo_alerta, 'El corte "' || :NEW.nombre || '" (stock: ' || :NEW.stock_actual_kg || ' kg) requiere reposición.');
        END IF;
    END IF;
END;
/


/************************************************************************************
*
* 4. PAQUETE CENTRALIZADO (PKG_INVENTARIO_CARNES)
*
************************************************************************************/

-- 4.1. Especificación del Paquete
CREATE OR REPLACE PACKAGE pkg_inventario_carnes AS

    -- Constantes públicas según especificación
    MAX_DELTA_KG        CONSTANT NUMBER := 1000; -- Máximo KG permitido en un solo movimiento
    DEFAULT_STOCK_MINIMO CONSTANT NUMBER := 10;   -- Valor por defecto para stock mínimo

    -- Excepciones de negocio personalizadas
    ex_stock_insuficiente       EXCEPTION;
    ex_cantidad_invalida        EXCEPTION;
    ex_tipo_movimiento_invalido EXCEPTION;
    ex_producto_no_encontrado   EXCEPTION;
    ex_orden_no_encontrada      EXCEPTION;
    ex_orden_ya_recibida        EXCEPTION;
    ex_orden_cancelada          EXCEPTION;

    -- Procedimientos y Funciones Públicas
    PROCEDURE registrar_movimiento(
        p_producto_id       IN NUMBER,
        p_tipo_movimiento   IN VARCHAR2,
        p_cantidad_kg       IN NUMBER,
        p_empleado_id       IN NUMBER,
        p_supermercado_id   IN NUMBER
    );

    FUNCTION verificar_stock_kg(p_producto_id IN NUMBER) RETURN NUMBER;

    PROCEDURE crear_orden_compra_header(
        p_proveedor_id      IN NUMBER,
        p_supermercado_id   IN NUMBER,
        p_nueva_orden_id    OUT NUMBER
    );

    PROCEDURE agregar_detalle_orden(
        p_orden_id          IN NUMBER,
        p_producto_id       IN NUMBER,
        p_cantidad_kg       IN NUMBER,
        p_precio_por_kg     IN NUMBER
    );

    PROCEDURE recibir_orden_compra(
        p_orden_id      IN NUMBER,
        p_empleado_id   IN NUMBER
    );

    FUNCTION obtener_productos_bajo_minimo(
        p_categoria_id IN NUMBER
    ) RETURN productos_alerta_varray;

    PROCEDURE registrar_auditoria_conteo (
        p_producto_id       IN NUMBER,
        p_cantidad_real_kg  IN NUMBER,
        p_empleado_id       IN NUMBER,
        p_supermercado_id   IN NUMBER,
        p_motivo            IN VARCHAR2 DEFAULT 'CONTEO FISICO'
    );

END pkg_inventario_carnes;
/

-- 4.2. Cuerpo del Paquete
CREATE OR REPLACE PACKAGE BODY pkg_inventario_carnes AS

    -- Mapeo de excepciones a códigos de error estándar
    PRAGMA EXCEPTION_INIT(ex_stock_insuficiente,       -20010);
    PRAGMA EXCEPTION_INIT(ex_cantidad_invalida,        -20011);
    PRAGMA EXCEPTION_INIT(ex_tipo_movimiento_invalido, -20012);
    PRAGMA EXCEPTION_INIT(ex_producto_no_encontrado,   -20013);
    PRAGMA EXCEPTION_INIT(ex_orden_no_encontrada,      -20022);
    PRAGMA EXCEPTION_INIT(ex_orden_ya_recibida,        -20024);
    PRAGMA EXCEPTION_INIT(ex_orden_cancelada,          -20025);

    -- Procedimiento privado para centralizar la actualización de stock
    PROCEDURE p_actualizar_stock(p_producto_id IN NUMBER, p_delta_kg IN NUMBER) IS
    BEGIN
        UPDATE productos_carne
        SET stock_actual_kg = stock_actual_kg + p_delta_kg
        WHERE producto_id = p_producto_id;
    END p_actualizar_stock;

    PROCEDURE registrar_movimiento(
        p_producto_id       IN NUMBER,
        p_tipo_movimiento   IN VARCHAR2,
        p_cantidad_kg       IN NUMBER,
        p_empleado_id       IN NUMBER,
        p_supermercado_id   IN NUMBER
    ) IS
        v_stock_actual_kg NUMBER;
        v_sign NUMBER;
        v_movimiento_norm VARCHAR2(20) := UPPER(TRIM(p_tipo_movimiento));
    BEGIN
        -- Validación de cantidad según especificación
        IF p_cantidad_kg <= 0 OR p_cantidad_kg > MAX_DELTA_KG THEN
            RAISE ex_cantidad_invalida;
        END IF;

        -- Bloqueo pesimista para evitar race conditions
        SELECT stock_actual_kg INTO v_stock_actual_kg
        FROM productos_carne WHERE producto_id = p_producto_id FOR UPDATE;

        -- Lógica de negocio para tipo de movimiento
        IF v_movimiento_norm IN ('EGRESO', 'MERMA') THEN
            IF v_stock_actual_kg < p_cantidad_kg THEN
                RAISE ex_stock_insuficiente;
            END IF;
            v_sign := -1;
        ELSIF v_movimiento_norm = 'INGRESO' THEN
            v_sign := 1;
        ELSE
            RAISE ex_tipo_movimiento_invalido;
        END IF;

        -- Insertar el registro del movimiento
        INSERT INTO movimientos_inventario (
            producto_id, tipo_movimiento, cantidad_kg, empleado_id, supermercado_id
        ) VALUES (
            p_producto_id, v_movimiento_norm, p_cantidad_kg, p_empleado_id, p_supermercado_id
        );

        -- Actualizar el stock
        p_actualizar_stock(p_producto_id, v_sign * p_cantidad_kg);

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20013, 'Producto (corte) no encontrado: ' || p_producto_id);
    END registrar_movimiento;

    FUNCTION verificar_stock_kg(p_producto_id IN NUMBER) RETURN NUMBER IS
        v_stock_kg NUMBER;
    BEGIN
        SELECT stock_actual_kg INTO v_stock_kg FROM productos_carne WHERE producto_id = p_producto_id;
        RETURN v_stock_kg;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL; -- O lanzar ex_producto_no_encontrado según se prefiera
    END verificar_stock_kg;

    PROCEDURE crear_orden_compra_header(
        p_proveedor_id      IN NUMBER,
        p_supermercado_id   IN NUMBER,
        p_nueva_orden_id    OUT NUMBER
    ) IS
    BEGIN
        INSERT INTO ordenes_compra (proveedor_id, supermercado_id, total)
        VALUES (p_proveedor_id, p_supermercado_id, 0)
        RETURNING orden_id INTO p_nueva_orden_id;
    EXCEPTION
        WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR(-20020, 'Error al crear la cabecera de la orden: ' || SQLERRM);
    END crear_orden_compra_header;

    PROCEDURE agregar_detalle_orden(
        p_orden_id          IN NUMBER,
        p_producto_id       IN NUMBER,
        p_cantidad_kg       IN NUMBER,
        p_precio_por_kg     IN NUMBER
    ) IS
    BEGIN
        INSERT INTO detalle_orden (orden_id, producto_id, cantidad_kg, precio_por_kg)
        VALUES (p_orden_id, p_producto_id, p_cantidad_kg, p_precio_por_kg);

        UPDATE ordenes_compra
        SET total = NVL(total, 0) + (p_cantidad_kg * p_precio_por_kg)
        WHERE orden_id = p_orden_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR(-20021, 'Orden ID (' || p_orden_id || ') o Producto ID (' || p_producto_id || ') no existe.');
        WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR(-20020, 'Error al agregar detalle a la orden: ' || SQLERRM);
    END agregar_detalle_orden;

    PROCEDURE recibir_orden_compra(
        p_orden_id      IN NUMBER,
        p_empleado_id   IN NUMBER
    ) IS
        CURSOR c_detalle IS
            SELECT producto_id, cantidad_kg FROM detalle_orden WHERE orden_id = p_orden_id;
        v_supermercado_id NUMBER;
        v_orden_estado    VARCHAR2(20);
    BEGIN
        SELECT estado, supermercado_id
        INTO v_orden_estado, v_supermercado_id
        FROM ordenes_compra WHERE orden_id = p_orden_id FOR UPDATE;

        IF v_orden_estado = 'RECIBIDA' THEN
            RAISE ex_orden_ya_recibida;
        ELSIF v_orden_estado = 'CANCELADA' THEN
             RAISE ex_orden_cancelada;
        END IF;

        FOR v_row IN c_detalle LOOP
            registrar_movimiento(
                p_producto_id       => v_row.producto_id,
                p_tipo_movimiento   => 'INGRESO',
                p_cantidad_kg       => v_row.cantidad_kg,
                p_empleado_id       => p_empleado_id,
                p_supermercado_id   => v_supermercado_id
            );
        END LOOP;

        UPDATE ordenes_compra SET estado = 'RECIBIDA' WHERE orden_id = p_orden_id;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE ex_orden_no_encontrada;
    END recibir_orden_compra;

    FUNCTION obtener_productos_bajo_minimo (
        p_categoria_id IN NUMBER
    ) RETURN productos_alerta_varray
    IS
        v_lista_ids productos_alerta_varray := productos_alerta_varray();
    BEGIN
        SELECT producto_id
        BULK COLLECT INTO v_lista_ids
        FROM productos_carne
        WHERE categoria_id = p_categoria_id
          AND stock_actual_kg < stock_minimo_kg;

        RETURN v_lista_ids;
    EXCEPTION
        WHEN OTHERS THEN
            -- En caso de error, devolver una colección vacía para no romper el flujo del cliente.
            RETURN productos_alerta_varray();
    END obtener_productos_bajo_minimo;

    PROCEDURE registrar_auditoria_conteo (
        p_producto_id       IN NUMBER,
        p_cantidad_real_kg  IN NUMBER,
        p_empleado_id       IN NUMBER,
        p_supermercado_id   IN NUMBER,
        p_motivo            IN VARCHAR2 DEFAULT 'CONTEO FISICO'
    )
    IS
        v_stock_sistema_kg NUMBER;
        v_diferencia_kg    NUMBER;
    BEGIN
        IF p_cantidad_real_kg < 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'La cantidad real contada no puede ser negativa.');
        END IF;

        BEGIN
            SELECT stock_actual_kg INTO v_stock_sistema_kg
            FROM productos_carne WHERE producto_id = p_producto_id FOR UPDATE;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE ex_producto_no_encontrado;
        END;

        v_diferencia_kg := p_cantidad_real_kg - v_stock_sistema_kg;

        IF v_diferencia_kg != 0 THEN
            INSERT INTO auditorias_inventario (
                producto_id, fecha_hora, empleado_id, supermercado_id,
                stock_sistema_kg, stock_real_kg, diferencia_kg, motivo
            ) VALUES (
                p_producto_id, SYSTIMESTAMP, p_empleado_id, p_supermercado_id,
                v_stock_sistema_kg, p_cantidad_real_kg, v_diferencia_kg, p_motivo
            );

            UPDATE productos_carne
            SET stock_actual_kg = p_cantidad_real_kg
            WHERE producto_id = p_producto_id;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            -- Según especificación, no hacer ROLLBACK, solo relanzar la excepción.
            RAISE;
    END registrar_auditoria_conteo;

END pkg_inventario_carnes;
/

SET SERVEROUTPUT ON;
COMMIT;

/************************************************************************************
*
* SECCIÓN DE PRUEBAS
*
************************************************************************************/


/************************************************************************************
*
* 1. INSERCIÓN DE DATOS DE PRUEBA (40 INSERCIONES)
*
************************************************************************************/
BEGIN
    DBMS_OUTPUT.PUT_LINE('--- 1. Creando 40 registros iniciales... ---');

    -- Insertar Supermercados
    INSERT INTO supermercados (nombre, direccion) VALUES ('Supermercado Central', 'Av. Principal 123');
    INSERT INTO supermercados (nombre, direccion) VALUES ('Sucursal Norte', 'Calle Falsa 456');
    INSERT INTO supermercados (nombre, direccion, estado) VALUES ('Bodega Logística', 'Ruta 5 Sur Km 100', 'I');

    -- Insertar Empleados
    INSERT ALL
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('Juan Pérez', '1-1', 'Jefe de Carnicería', 1)
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('Ana Rojas', '2-2', 'Carnicera', 1)
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('Carlos Muñoz', '3-3', 'Bodeguero', 3)
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('María López', '4-4', 'Carnicera', 2)
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('Pedro Soto', '5-5', 'Jefe de Sección', 2)
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('Luisa Vera', '6-6', 'Ayudante Carnicero', 1)
        INTO empleados (nombre, rut, cargo, supermercado_id) VALUES ('Jorge Díaz', '7-7', 'Reponedor', 2)
        INTO empleados (nombre, rut, cargo, supermercado_id, estado) VALUES ('Elena Gómez', '8-8', 'Ex-Carnicera', 1, 'I')
    SELECT 1 FROM DUAL;

    -- Insertar Proveedores
    INSERT ALL
        INTO proveedores (nombre, rut, correo, supermercado_id) VALUES ('Frigorífico del Sur', '77.123.456-K', 'ventas@frigosur.cl', 1)
        INTO proveedores (nombre, rut, correo, supermercado_id) VALUES ('Carnes Premium Ltda.', '78.987.654-J', 'contacto@carnespremium.cl', 1)
        INTO proveedores (nombre, rut, correo, supermercado_id) VALUES ('Distribuidora Andina', '76.543.210-9', 'pedidos@andina.com', 2)
        INTO proveedores (nombre, rut, correo, supermercado_id) VALUES ('Aves del Campo', '75.111.222-3', 'aves@campo.cl', 1)
        INTO proveedores (nombre, rut, correo, supermercado_id, estado) VALUES ('Proveedor Antiguo', '70.000.000-0', 'old@prov.com', 1, 'I')
    SELECT 1 FROM DUAL;

    -- Insertar Categorías
    INSERT ALL
        INTO categorias_carne (nombre, supermercado_id) VALUES ('Vacuno', 1)
        INTO categorias_carne (nombre, supermercado_id) VALUES ('Pollo', 1)
        INTO categorias_carne (nombre, supermercado_id) VALUES ('Cerdo', 1)
        INTO categorias_carne (nombre, supermercado_id) VALUES ('Pavo', 2)
        INTO categorias_carne (nombre, supermercado_id) VALUES ('Cordero', 1)
    SELECT 1 FROM DUAL;

    -- Insertar Productos
    -- Vacuno (Cat 1)
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Lomo Vetado', 1, 19990, 5.0, 1, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Asiento Picana', 1, 15500, 8.0, 2, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Entraña', 1, 22500, 3.0, 1, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Posta Negra', 1, 11990, 10.0, 2, 2);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Tapabarriga', 1, 13490, 6.0, 1, 1);
    -- Pollo (Cat 2)
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Pechuga Entera', 2, 6990, 10.0, 4, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_actual_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Trutro Corto', 2, 4500, 15.0, 5.0, 4, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Alitas de Pollo', 2, 3990, 12.0, 4, 2);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Pollo Entero Faenado', 2, 3500, 8.0, 4, 1);
    -- Cerdo (Cat 3)
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Pulpa Pierna', 3, 7200, 7.5, 2, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Costillar Ahumado', 3, 9900, 4.0, 2, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Lomo Centro', 3, 8500, 5.0, 3, 2);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Chuleta Parrillera', 3, 7990, 6.0, 3, 1);
    -- Pavo (Cat 4)
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Pechuga de Pavo Deshuesada', 4, 8990, 5.0, 4, 2);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Pavo Entero Congelado', 4, 5500, 3.0, 4, 2);
    -- Cordero (Cat 5)
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Pierna de Cordero', 5, 14990, 2.0, 1, 1);
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id) VALUES ('Chuletas de Cordero', 5, 18990, 2.5, 2, 1);
    -- Producto Inactivo
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, proveedor_id, supermercado_id, estado) VALUES ('Corte Descontinuado', 1, 5000, 1.0, 1, 1, 'I');
    -- Producto sin proveedor asignado
    INSERT INTO productos_carne (nombre, categoria_id, precio_por_kg, stock_minimo_kg, supermercado_id) VALUES ('Carne Molida Especial', 1, 9500, 10.0, 1);

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('40 registros iniciales creados con éxito.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error al insertar datos de prueba: ' || SQLERRM);
        ROLLBACK;
END;
/


/************************************************************************************
*
* 2. PRUEBAS DE MOVIMIENTOS DE INVENTARIO
*
************************************************************************************/
DECLARE
    v_stock_pechuga NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.1 Prueba: Verificar stock inicial CERO ---');
    v_stock_pechuga := pkg_inventario_carnes.verificar_stock_kg(6); -- Pechuga Entera
    DBMS_OUTPUT.PUT_LINE('Stock inicial de Pechuga (ID 6): ' || v_stock_pechuga || ' kg (Esperado: 0)');

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.2 Prueba: Ingreso inicial de varios productos ---');
    pkg_inventario_carnes.registrar_movimiento(1, 'INGRESO', 20.5, 1, 1);
    pkg_inventario_carnes.registrar_movimiento(6, 'INGRESO', 35.0, 1, 1);
    pkg_inventario_carnes.registrar_movimiento(10, 'INGRESO', 15.8, 1, 1);
    DBMS_OUTPUT.PUT_LINE('Ingresos registrados para Lomo(1), Pechuga(6) y Pulpa(10).');

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.3 Prueba: Registrar MERMA ---');
    pkg_inventario_carnes.registrar_movimiento(10, 'MERMA', 0.3, 2, 1);
    DBMS_OUTPUT.PUT_LINE('MERMA de 0.3 kg de Pulpa Pierna (ID 10) registrada.');

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 2.4 Prueba: Egreso que activa alerta de bajo stock ---');
    pkg_inventario_carnes.registrar_movimiento(1, 'EGRESO', 16.0, 2, 1);
    DBMS_OUTPUT.PUT_LINE('EGRESO de 16.0 kg de Lomo Vetado (ID 1) registrado. Stock actual: 4.5 kg.');

    COMMIT;
END;
/


/************************************************************************************
*
* 3. PRUEBAS DE VALIDACIONES Y ERRORES CONTROLADOS
*
************************************************************************************/
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 3.1 Prueba Fallida: Registrar movimiento con cantidad negativa ---');
    BEGIN
        pkg_inventario_carnes.registrar_movimiento(1, 'INGRESO', -5.0, 1, 1);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió registrar cantidad negativa.');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
    END;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 3.2 Prueba Fallida: Agregar detalle a orden inexistente ---');
    BEGIN
        pkg_inventario_carnes.agregar_detalle_orden(999, 1, 1.0, 19000);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió agregar detalle a orden 999.');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
    END;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 3.3 Prueba Fallida: Registrar MERMA con stock insuficiente ---');
    BEGIN
        -- Quedan 4.5 kg de Lomo (ID 1), intentamos mermar 5kg
        pkg_inventario_carnes.registrar_movimiento(1, 'MERMA', 5.0, 2, 1);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió MERMA con stock insuficiente.');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
    END;
END;
/


/************************************************************************************
*
* 4. PRUEBA DEL PROCESO DE COMPRA COMPLETO
*
************************************************************************************/
DECLARE
    v_nueva_orden_id NUMBER;
    v_stock_antes NUMBER;
    v_stock_despues NUMBER;
    v_orden_estado VARCHAR2(20);
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 4.1 Prueba Compra: Crear cabecera de Orden ---');
    pkg_inventario_carnes.crear_orden_compra_header(1, 1, v_nueva_orden_id);
    DBMS_OUTPUT.PUT_LINE('Orden de compra creada con ID: ' || v_nueva_orden_id);

    DBMS_OUTPUT.PUT_LINE('--- 4.2 Prueba Compra: Agregar detalles a la orden ---');
    pkg_inventario_carnes.agregar_detalle_orden(v_nueva_orden_id, 6, 30.0, 6500); -- Pechuga
    pkg_inventario_carnes.agregar_detalle_orden(v_nueva_orden_id, 7, 25.0, 4000); -- Trutro
    DBMS_OUTPUT.PUT_LINE('Productos agregados a la orden.');

    SELECT estado INTO v_orden_estado FROM ordenes_compra WHERE orden_id = v_nueva_orden_id;
    v_stock_antes := pkg_inventario_carnes.verificar_stock_kg(6);
    DBMS_OUTPUT.PUT_LINE('Estado actual de la orden: ' || v_orden_estado);
    DBMS_OUTPUT.PUT_LINE('Stock de Pechuga (ID 6) ANTES de recibir: ' || v_stock_antes || ' kg');

    DBMS_OUTPUT.PUT_LINE('--- 4.3 Prueba Compra: Recibir el pedido ---');
    pkg_inventario_carnes.recibir_orden_compra(v_nueva_orden_id, 1);
    v_stock_despues := pkg_inventario_carnes.verificar_stock_kg(6);
    SELECT estado INTO v_orden_estado FROM ordenes_compra WHERE orden_id = v_nueva_orden_id;
    DBMS_OUTPUT.PUT_LINE('¡Orden RECIBIDA! El stock ha sido actualizado.');
    DBMS_OUTPUT.PUT_LINE('Stock de Pechuga (ID 6) DESPUÉS de recibir: ' || v_stock_despues || ' kg');
    DBMS_OUTPUT.PUT_LINE('Estado final de la orden: ' || v_orden_estado);
    COMMIT;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 4.4 Prueba Fallida: Intentar recibir la misma orden de nuevo ---');
    BEGIN
        pkg_inventario_carnes.recibir_orden_compra(v_nueva_orden_id, 1);
        DBMS_OUTPUT.PUT_LINE('FALLO: Se permitió recibir una orden ya procesada.');
    EXCEPTION
        WHEN pkg_inventario_carnes.ex_orden_ya_recibida THEN
            DBMS_OUTPUT.PUT_LINE('ÉXITO (Fallo esperado): ' || SQLERRM);
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('FALLO INESPERADO: ' || SQLERRM);
    END;
END;
/

/************************************************************************************
*
* 5. PRUEBA DE FUNCIÓN CON COLECCIONES (VARRAY)
*
************************************************************************************/
DECLARE
    v_lista_ids_vacuno productos_alerta_varray;
    v_lista_ids_pollo  productos_alerta_varray;
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 5.1 Prueba Colecciones: Obtener productos BAJO MÍNIMO de Vacuno ---');
    -- Lomo (ID 1) debería estar bajo mínimo (4.5kg < 5kg) tras la prueba 2.4
    v_lista_ids_vacuno := pkg_inventario_carnes.obtener_productos_bajo_minimo(p_categoria_id => 1);

    IF v_lista_ids_vacuno.COUNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Productos Vacuno bajo mínimo encontrados (' || v_lista_ids_vacuno.COUNT || '):');
        FOR i IN 1..v_lista_ids_vacuno.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('- ID Producto: ' || v_lista_ids_vacuno(i));
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('No se encontraron productos Vacuno bajo mínimo.');
    END IF;

    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 5.2 Prueba Colecciones: Obtener productos BAJO MÍNIMO de Pollo ---');
    -- Trutro Corto (ID 7) fue insertado con stock (15kg) > mínimo (5kg). No debería aparecer.
    -- Pechuga (ID 6) tiene stock alto. No debería aparecer.
    v_lista_ids_pollo := pkg_inventario_carnes.obtener_productos_bajo_minimo(p_categoria_id => 2);

    IF v_lista_ids_pollo.COUNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Productos Pollo bajo mínimo encontrados (' || v_lista_ids_pollo.COUNT || '):');
        FOR i IN 1..v_lista_ids_pollo.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('- ID Producto: ' || v_lista_ids_pollo(i));
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('No se encontraron productos Pollo bajo mínimo, como se esperaba.');
    END IF;
END;
/


/************************************************************************************
*
* 6. PRUEBA DE AUDITORÍA DE CONTEO FÍSICO
*
************************************************************************************/
DECLARE
    v_producto_id_test    CONSTANT NUMBER := 6; -- Pechuga Entera
    v_stock_antes         NUMBER;
    v_stock_despues       NUMBER;
    v_conteo_real_kg      CONSTANT NUMBER := 60.0;
BEGIN
    DBMS_OUTPUT.PUT_LINE(CHR(10) || '--- 6.1 Prueba Auditoría: Ajuste por Conteo Físico ---');

    -- Verificar stock del sistema ANTES del ajuste (debería ser 65.0 kg tras la prueba 4)
    v_stock_antes := pkg_inventario_carnes.verificar_stock_kg(v_producto_id_test);
    DBMS_OUTPUT.PUT_LINE('Stock en Sistema (Antes): ' || v_stock_antes || ' kg para Producto ID ' || v_producto_id_test);

    -- Simular y ejecutar el conteo
    DBMS_OUTPUT.PUT_LINE('Realizando conteo... Cantidad física contada: ' || v_conteo_real_kg || ' kg.');
    DBMS_OUTPUT.PUT_LINE('Se espera un ajuste/diferencia de: ' || (v_conteo_real_kg - v_stock_antes) || ' kg.');

    pkg_inventario_carnes.registrar_auditoria_conteo(
        p_producto_id       => v_producto_id_test,
        p_cantidad_real_kg  => v_conteo_real_kg,
        p_empleado_id       => 5,  -- Pedro Soto
        p_supermercado_id   => 1,
        p_motivo            => 'AJUSTE POR CONTEO SEMANAL'
    );

    -- Verificar el stock del sistema DESPUÉS del ajuste
    v_stock_despues := pkg_inventario_carnes.verificar_stock_kg(v_producto_id_test);
    DBMS_OUTPUT.PUT_LINE('Stock en Sistema (Después): ' || v_stock_despues || ' kg.');

    IF v_stock_despues = v_conteo_real_kg THEN
        DBMS_OUTPUT.PUT_LINE('ÉXITO: El stock del sistema se ha corregido al conteo real.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('FALLO: El stock del sistema NO se corrigió correctamente.');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Prueba 6.1 fallida: ' || SQLERRM);
        ROLLBACK;
END;
/

-- Verificación final de los resultados de la auditoría
PROMPT --- Verificando resultado en tabla de auditoría para producto 6:
SELECT * FROM auditorias_inventario WHERE producto_id = 6 ORDER BY fecha_hora DESC;

PROMPT --- Verificando stock final del producto 6:
SELECT producto_id, nombre, stock_actual_kg FROM productos_carne WHERE producto_id = 6;

PROMPT --- PRUEBAS FINALIZADAS ---
 



